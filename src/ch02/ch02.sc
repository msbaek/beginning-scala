for {i <- 1 to 10}
  println(i)


















// multilined string
def multilinedString = """Hello
Multiline
Word"""
println(multilinedString)


// class
class Bar(name: String)

new Bar("Working...")

// trait
trait Cat {
  def meow(): String
}

trait FuzzyCat extends Cat {
  override def meow(): String = "Meeeeeow"
}

trait OtherThing {
  def hello() = 4
}

class Yep extends FuzzyCat with OtherThing

// object
object Dude extends Yep

object Dude2 extends Yep {
  override def meow() = "Dude looks like a cat"
}

object OtherDude extends Yep {
  def twoMeows(param: Yep) = meow + ", " + param.meow()
}

OtherDude.meow()
OtherDude.twoMeows(Dude)
OtherDude.twoMeows(Dude2)
// embed an object
class HasYep {

  object myYep extends Yep {
    override def meow = "Moof"
  }

}

(new HasYep).myYep.meow

// classes, objects, traits can have inner classes, objects, traits
class HasClass {

  private class MyDude extends FuzzyCat

  def makeOne(): FuzzyCat = new MyDude
}

// import can be used inside any code block,
// and the import will be active only in the scope of that code block
class Frog {

  import scala.xml._

  def n: NodeSeq = NodeSeq.Empty
}

// static import와 같은 효과. method import
object Moose {
  def bark = "woof"
}

import java.io.BufferedReader
import java.util.Date
import Moose._
bark
// variable length argument
def larest(as: Int*): Int = as.reduceLeft((a, b) => a max b)
larest(2, 3, 99)
// method within a method
def readLines(br: BufferedReader) = {
  var ret: List[String] = Nil
  def readAll(): Unit = br.readLine() match {
    case null =>
    case s => ret ::= s; readAll()
  }
  readAll()
  ret.reverse
}

// 수퍼클래스에 선언된 메소드를 오버라이드하려면 반드시 override를 사용해야 함
// abstract method를 오버라이드하는 경우 override는 포함될 수도
abstract class Base {
  def thing: String
}

class One extends Base {
  def thing = "Moof"
}

// 인자가 없는 메소드는 변수와 같은 방식으로 접근된
// val 수퍼클래스의 def를 override할 수 있음
class Two extends One {
  override val thing = (new java.util.Date).toString
}

class Three extends One {
  override lazy val thing = super.thing + (new java.util.Date).toString
}

// val is executed when it is defined
// whereas a lazy val is executed when it is accessed the first time.

// variable declaration
// var variables can be changed after they are set, like Java variables.
// val variables are assignonce, and the value is calculated
// when the code block containing the val is entered, like final variables in Java.
// lazy val variables are calculated once, the first time the variable is accessed.
// useful when variable may not be used and the cost of calculating it is very long.
var y: String = "Moof"
val x: String = "Moof"
//lazy val lz: String = someLongQuery()

// multiple assignment
val (i1: Int, s2: String) = Pair(33, "Moof")




// call by name
def nano() = {
  println("Getting nano")
  System.nanoTime()
}
def delayed(t: => Long) {
  println("In delayed method")
  println("Param: "+ t)
  t
}
delayed(nano)





def notDelayed(t: Long) {
  println("In not deplayed method")
  println("Param: "+ t)
  t
}




notDelayed(nano)


2.1.*(4.3) == 2.1 * 4.3

// case classes(toString, hashCode, equals generated by compiler)
// without new
case class Stuff(name: String, age: Int)
val s = Stuff("David", 45)
s.toString
s == Stuff("David", 45)
s.name

// basic pattern matching
44 match {
  case 44 => true
  case _ => false
}

"David" match {
  case "David" => 45
  case "Elwood" => 77
  case _ => 0
}

Stuff("David", 45) match {
  case Stuff("David", 45) => true
  case _ => false
}

// test name but accept any age
Stuff("David", 45) match {
  case Stuff("David", _) => "David"
  case _ => "Other"
}

// can extract the age field into the howOld variable
Stuff("David", 45) match {
  case Stuff("David", howOld) => "David, age: " + howOld
  case _ => "Other"
}

// place a guard between pattern and =>
Stuff("David", 45) match {
  case Stuff("David", age) if age < 30 => "young David"
  case Stuff("David", _) => "old David"
  case _ => "Other"
}

// can test whether the input is an instance of a given class
// and do the casting if it is:
x match {
//  case d: java.util.Date => "The date in milliseconds is " + d.getTime
//  case u: java.net.URL => "The URL path: " + u.getPath
  case s: String => "String: " + s
  case _ => "Something else"
}

val exp = true
var i: Int = if(exp) 1 else 3

// for statement
for{i <- 1 to 3} println(i)
for{i <- 1 to 3;j <- 1 to 3} println(i * j)
for{i <- 1 to 3
    j <- 1 to 3} println(i * j)
// guard
def isOdd(in: Int) = in % 2 == 1
for{i <- 1 to 5 if isOdd(i)} println(i)
val lst = (1 to 18 by 3).toList

// yield
for{i <- 1 to 5 if isOdd(i)} yield i

// try-catch
//try {
//  file.write(stuff)
//} catch {
//  case e: java.io.IOException => // handle IO Exception
//  case n: NullPointerException => // handle null pointer
//}
try {
  Integer.parseInt("dog")
}
catch {
  case _ => 0
}
// synchronize
// on instance
"sss".synchronized {
  // do something
}

//no synchronized modifier for methods
def foo(): Int = synchronized {
  42
}



